# 브릿지
## 브릿지 정의
브릿지 패턴은 큰 클래스 또는 밀접하게 관련된 클래스들의 집합을 두 개의 개별 계층구조(추상화 및 구현)로 나눈 후 각각 독립적으로 개발할 수 있도록 하는 구조 디자인 패턴이다.

## 브릿지 장점
1. 변경 용이성
   - 브릿지는 추상화와 구현을 분리하므로, 각각의 변화가 다른 영역에 영향을 미치지 않는다.
   - 하나의 구현이 변경되더라도 다른 구현이나 클라이언트 코드에 영향을 미치지 않는다.
2. 유연성
   - 구현과 추상화를 독립적으로 확장할 수 있다.
   - 새로운 구현을 추가하거나 기존의 구현을 변경할 때, 클라이언트 코드를 수정하지 않고도 확장이 가능하다.
3. 복잡성 감소
   - 복잡한 클래스 계층 구조를 피할 수 있도록 도와준다.
   - 상속을 사용하여 구현과 추상화를 분리함으로써, 복잡한 계층 구조를 간소화할 수 있다.
4. 재사용성
   - 구현과 추상화를 독립적으로 관리하므로, 각 요소를 재사용하기 쉽다.
   - 특히, 다양한 구현을 가진 다른 추상화를 만들 수 있다.
5. 클라이언트 코드의 단순화
   - 브릿지 패턴을 사용하면 클라이언트 코드가 특정 구현에 의존하지 않고, 추상화에만 의존하게 된므로, 클라이언트 코드가 단순화되어 읽기 쉬워진다.
6. 확장성
   - 새로운 구현을 추가하거나 기존 구현을 수정함으로써 시스템의 확장성을 높일 수 있다.
   - 새로운 구현을 추가하는 것은 간단하고 기존 코드에 영향을 미치지 않는다.
   
## 브릿지 문제점
![image](https://github.com/backgame1312/DesignPattern/assets/127277391/54097de1-5b7d-4f7c-a77c-c356f671e0c4)   
``Circle``과 ``Square``라는 한 쌍의 자식 클래스들이 있는 ``Shape`` 클래스가 있다고 가정해보자. 색상을 통합하도록 이 클래스 계층을 확장하려는 경우 Red 및 Blue 모양 자식 클래스를 만들 계획이다. 그러나 이미 두 개의 자식 클래스``(Form, Color)``가 있으므로 ``BlueCircle`` 및 ``RedSquare``와 같은 네 개의 클래스 조합을 생성해야 한다.    
   
지금은 4건이지만, 클래스 계층 구조에 새로운 모양 유형 및 색상을 추가하면 이 수는 기하 급수적으로 증가한다. 예를 들어 삼각형 모양을 추가하려면 각 색상에 하나씩 두 개의 하위 클래스를 추가해야한다. 그 후에 새로운 색상을 추가하려면, 각 모양에 하나씩 3개의 하위 클래스를 추가적으로 만들어야 한다. 유형들이 많아지면 많아질수록 코드는 점점 복잡해지게 된다.

### 브릿지 문제 해결책
![image](https://github.com/backgame1312/DesignPattern/assets/127277391/57d248c9-e44e-4d3a-97b7-f6f6553a024f)   
이 문제는 ``Form(circle, square)``과 ``Color(red, blue)``의 두 가지 독립적인 차원으로 ``Shape`` 클래스를 확장하려고 하기 때문에 발생한다. 이는 클래스 상속과 관련해서는 매우 흔한 문제이다.
브릿지 패턴은 이러한 문제를 상속에서 객체 합성으로 전환하여 해결한다. 즉, 한 클래스 내에서 모든 상태와 동작을 포함하는 대신 원래 클래스가 새 계층의 객체를 참조하도록 계층 중 하나를 별도의 클래스 계층 구조로 추출한다.   
   
이 접근법에 따라 구조를 보면 ``Shape``라는 클래스를 추출하여 ``Color`` 클래스와 나누고 색상 객체 중 하나를 가리키는 참조 필드를 가져온다. 이제 ``Shape``은 연결된 ``Color`` 객체에 모든 색상 관련 작업을 위임할 수 있다. 이 참조는 일종의 ’다리‘ 역할을 하게된다.

## 브릿지 구조
![image](https://github.com/backgame1312/DesignPattern/assets/127277391/be6c8429-1162-4617-9fff-d4fdb0b4314e)
1. ``추상화``는 상위 수준의 제어 논리를 제공하며, 구현 객체에 의존해 실제 하위 수준 작업들을 수행한다.
2. ``구현``은 모든 구상 구현들에 공통적인 인터페이스를 선언하며, 추상화는 여기에 선언된 함수들을 통해서만 구현 객체와 소통할 수 있다.
   > 추상화는 구현과 같은 함수들을 나열할 수 있지만 보통은 구현이 선언한 다양한 원시 작업들에 의존하는 몇 가지 복잡한 행동들을 선언한다.
3. ``구상 구현들``에는 플랫폼별 맞춤형 코드가 포함된다.
4. ``정제된 추상화들``은 제어 논리의 변형들을 제공한다. 이들은 이들의 부모처럼 일반 구현 인터페이스를 통해 다른 구현들과 작업한다.
5. 일반적으로 ``클라이언트``는 추상화와 작업하는데만 관심이 있다. 그러나 추상화 객체들 중 하나와 연결하는 것도 클라이언트의 역할이다.

