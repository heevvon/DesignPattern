# 빌더
복잡한 객체를 생성하는 방법을 정의하는 클래스와 표현하는 방법을 정의하는 클래스를 별도로 분리하여, 서로 다른 표현이라도 이를 생성할 수 있는 동일한 절차를 제공하는 패턴이다.

## 사용하는 이유
* 객체 생성과 초기화 과정이 복잡하고, 생성자에서 처리해야 할 매개변수의 개수가 많을 때 빌더 패턴은 생성자에서 처리해야 할 매개변수를 단계적으로 처리하고, 객체 생성과 초기화 과정을 간소화한다.
* 빌더 패턴은 객체 생성과 초기화 과정을 분리하고, 객체 생성에 필요한 매개변수를 명시적으로 처리함으로써, 코드의 가독성을 향상시킨다. 이는 유지 보수와 코드 재사용성을 높이는 데 도움이 된다.

## 문제
많은 필드와 중첩된 객체들을 단계 별로 초기화해야 하는 복잡한 객체라고 가정할 때, 이러한 초기화 코드는 일반적으로 많은 매개변수가 있는 생성자에 있기 마련이다.

![image](https://github.com/backgame1312/DesignPattern/assets/103929632/6f6e41de-8e1f-49a6-89a3-ff73df68048d)

위와 같이 House를 만든다고 생각했을 때, 집을 만들기 위해 벽, 문, 창문, 지붕 등 다양한 것들을 기반으로 만들어져야 한다.

![image](https://github.com/backgame1312/DesignPattern/assets/103929632/a1d71835-a050-4911-a98c-219f516b11b8)

이를 House의 생성자에 전부 넣어 만드는 방법이 있는데 이는 대부분의 매개변수가 사용되지 않아 생성자의 코드가 매우 못생겨질 것이다.

## 해결책
빌더 패턴은 자신의 클래스에서 객체 생성 코드를 추출하여 builders라는 별도의 객체들로 이동하도록 제안한다.

![image](https://github.com/backgame1312/DesignPattern/assets/103929632/cd56585a-044a-4786-bb35-94ef46b1524b)

빌더는 제품이 생성되는 동안 다른 개체들이 제품에 접근하는 것을 허용하지 않는다.

객체 생성을 일련의 단계들로 정리하며 객체를 생성하고 싶으면 위 단계들을 빌더 객체에 실행하면 되고, 모든 단계를 호출할 필요 없이 필요한 단계들만 호출하면 된다.

## 빌더 구조
![image](https://github.com/backgame1312/DesignPattern/assets/103929632/2a701241-e8cd-432b-9744-e0953f5e46cf)
* **Builder Interface**: 모든 유형의 빌더에 사용되는 공통적인 단계를 선언한다.
* **Concrete Builder**: 생성 단계에서 서로 다른 구현제를 제공한다. 이 구현체는 공통 인터페이스를 따르지 않는 다른 빌더를 만들 수도 있다.
* **Product1, Product2**: 결과 객체이다. 이들은 동일한 클래스 계층 구조나 인터페이스에 속할 필요가 없다.
* **Director**: 개발자가 특정 Product의 구성을 생성하고 재사용할 수 있도록 생성 단계를 호출하는 순서를 지정한다.
* **Client**: Director 클래스와 함께 빌더 객체 중 하나와 연결되어야 한다.

## 장단점
### 장점
* 객체를 단계별로 생성하거나 생성 단계를 연기하거나 단계를 반복적으로 실행할 수 있다.
* 다양한 제품 표현을 제작할 때 동일한 빌더 코드를 재사용할 수 있다.
* 단일 책임 원칙을 지킬 수 있다.
### 단점 
* 패턴은 여러 개의 새 클래스를 만들어야 하므로 코드의 전반적인 복잡성이 증가한다.


