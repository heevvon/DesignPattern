# 프로토타입
## 프로토타입 정의
프로토타입 패턴은 코드를 그들의 클래스에 의존시키지 않고, 기존 객체들을 복사할 수 있도록 하는 생성 디자인 패턴이다. 
복제를 지원하는 객체를 프로토타입이라고 한다.
프로토타입 패턴은 비슷한 객체가 이미 있는 경우에 사용되고, 복사를 위해 C++에서 제공하는 추상 메서드인 ``clone``을 사용한다. 
  
즉, 프로토타입 패턴은 원본 객체를 새로운 객체에 복사하여 필요에 따라 수정하는 매커니즘을 제공한다. 객체들에 수십, 수백 개의 데이터와 설정들이 있는 경우, 이를 복제하는 것이 서브 클래싱의 대안이 될 수 있다.

## 프로토타입 장점
1. 복잡한 객체를 만드는 과정을 숨길 수 있다.
2. 기존 객체를 복제하는 과정이 새 인스턴스를 만드는 것보다 비용면에서 효율적이다.
3. ``clone``에서 반환하는 타입이 ``clone``을 정의한 클래스와 반드시 동일할 필요는 없다. 클래스의 게층 구조가 있을 때, 추상화된 타입을 반환할 수 있는 유연성이 있다.
4. 프로토타입의 클래스 뿐만 아니라 상태도 같이 복제한다. 원형 클래스에 사용할 객체를 잘 설정하면 속도, 힘 등과 같은 다양한 특성의 객체를 쉽게 만들 수 있다.

## 문제점
복사하고 싶은 객체가 있고, 그 객체의 정확한 복사본을 만들고 싶다면 원본 객체의 모든 데이터들을 살펴본 후 해당 데이터들을 새 객체에 복사해야 한다. 하지만 객체의 데이터들 중 일부가 비공개여서 객체 자체의 외부에서 볼 수 없을 수도 있기 때문에 모든 객체를 이런 식으로 복사할 수 없다.     
  
이 직접적 접근 방식에는 또 다른 문제들이 있다. 하나는 객체의 복제본을 생성하려면 객체의 클래스를 알아야하므로, 코드가 해당 클래스에 의존하게 되는 것이다.     
  
또, 메서드의 매개변수가 일부 인터페이스를 따르는 모든 객체를 수락할 때, 그 객체가 따르는 인터페이스만 알고, 그 객체의 구상 클래스는 알지 못할 수도 있다.
## 해결책
프로토타입 패턴은 실제로 복제되는 객체들에 복제 프로세스를 위임한다. 패턴은 복제를 지원하는 모든 객체에 대한 공통 인터페이스를 선언한다. 이 인터페이스를 사용하면 코드를 객체의 클레스에 결합하지 않고도 해당 객체를 복제할 수 있다. 일반적으로 단일 ``clone`` 메서드를 사용한다.  

### Clone 메서드
``clone`` 메서드는 현재 클래스의 객체를 만든 후 이전 객체의 모든 필드 값을 새 객체로 전달한다. 대부분의 프로그래밍 언어는 객체들이 같은 클레스에 속한 다른 객체의 비공개 필드에 접근할 수 있도록 하므로 비공개 필드를 복사하는 것도 가능하다.

## 프로토타입 구조
``Prototype``의 구조는 다음과 같다.  
![structure](https://github.com/backgame1312/DesignPattern/assets/127277391/55bed080-45f4-47a7-8aa8-f0981ee10b86)
1. 프로토타입 인터페이스는 복제 메서드들을 선언하며, 이 메서드들의 대부분은 단일 ``clone`` 메서드이다.
2. 구상 프로토타입 클래스는 복제 메서드를 구현한다. 원본 객체의 데이터를 복제본에 복사하는 것 이외에도 이 메서드는 복제 프로세스와 관련된 일부 예외적인 경우들도 처리할 수 있다  
(ex. 연결된 객체 복제, 재귀 종속성 풀기)
3. 클라이언트는 프로토타입 인터페이스를 따르는 모든 객체의 복사본을 생성할 수 있다.

### 상위 클래스
상위 클래스에 추상 메서드인 ``clone``이 존재해야 한다.
```C++
virtual [클래스 이름]* clone() = 0;
```
### 하위 클래스
하위 클래스에서는 자신의 자료형과 같은 새로운 객체를 반환하도록 ``clone``을 구현한다.  
아래는 상위 클래스를 Monster, 하위 클래스를 Zombie로 설정하여 좀비를 복제하는 프로그램 예시이다.
```C++
class Zombie : public Monster {
public:
  Zombie(int health, int speed) : Monster(health, speed) {}
  virtual Monster* clone() {
    return new Zombie(health, speed);
  }
};
```
만약 상위 클래스인 Monster를 상속받는 모든 클래스에 ``clone`` 메서드가 있다면, 스포너 클래스를 종류별로 만들 필요 없이 하나만 만들면 된다.  
아래는 스포너 클래스의 예시이다.
```C++
class Spawner {
  Monster* prototype;
public:
  Spawner(Monster* p) : prototype(p) {}

  Monster* spawnMonster() {
    return prototype->clone();
  }
};
```
스포너 클래스의 내부에는 Monster 객체가 존재한다. 이 객체는 자기와 같은 Monster 객체를 복사해 만들어내는 스포너 역할만 한다. 이렇게 스포너 클래스가 있는 상태에서 좀비 스포너를 만들려면 원형으로 사용할 좀비 인스턴스를 만든 후에 스포너에 전달한다.
```C++
int main () {
  Monster* zombiePrototype = new Zombie(15, 3);
  Spawner* zombieSpawner = new Spawner(zombiePrototype);
}
```
### 템플릿을 사용하는 경우
스포너 클래스를 이용해 인스턴스를 생성하고 싶지만 특정 몬스터 클래스를 직접 입력하기 싫다면 몬스터 클래스를 템플릿 타입 매개변수로 전달하면 된다.   
아래는 템플릿을 사용한 예시이다.
``` C++
template <class T>
class SpawnerTemplate : public Spawner {
public:
  virtual Monster* spawnMonster() {
    retrun new T();
  }
};
```
